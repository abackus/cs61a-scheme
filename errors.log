
(2 2)
(2)
(2 2)
(2 2)
(2 2)
(2)
(2 2)
(2)
(2 2)
(2)
(
quote
hello
(
quote
hello
'
hello
(
quote
hello
'
hello
'
'
hello
(
quote
hello
'
hello
(
quote
hello
'
hello
'
'
hello
(
quote
hello
'
(
quote
hello
'
hello
'
'
hello
(
quote
hello
'
hello
'
'
hello
(
quote
hello
(
quote
hello
'
hello
'
'
hello
(
quote
(
1
2
'
(
1
2
(
quote
(
1
2
'
(
1
(
2
(
car
'
(
1
2
3
(
cdr
'
(
1
2
(
car
(
car
'
(
(
1
(
quote
3
(
eval
(
cons
'
car
'
(
'
(
4
2
(
quote
x
'
x
(
a
b
'
(
a
b
'
(
(
a
(
a
(
b
'
c
(
a
(
b
'
(
c
d
'
)
'
)
'
(
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
'
hello
(
car
'
(
1
2
(
car
'
(
1
2
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
(
begin
(
+
2
3
(
+
5
6
(
begin
(
define
x
3
x
(
begin
30
'
(
+
2
2
(
define
x
0
(
begin
42
(
define
x
(
+
x
1
x
(
begin
30
'
hello
(
begin
(
define
x
3
(
cons
x
'
(
y
z
(
begin
(
define
x
3
(
cons
x
'
(
x
z
(
define
x
0
(
begin
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
lambda
(
x
y
(
+
x
y
(
lambda
(
x
(
+
x
(
+
x
x
(
lambda
(
x
(
lambda
(
2
(
lambda
(
x
y
x
(
define
(
f
x
y
(
+
x
y
(
define
(
f
x
y
(
+
x
y
f
(
define
(
f
(
+
2
2
f
(
define
(
f
x
(
*
x
x
f
(
define
(
foo
x
1
2
3
4
5
foo
(
define
(
foo
(
/
1
0
foo
(
define
(
f
x
x
(
define
(
f
x
x
(
define
size
2
size
(
define
x
(
+
2
3
x
(
define
x
(
+
2
7
x
(
eval
(
define
tau
6.28
(
define
pi
3.14159
(
define
radius
10
(
define
area
(
*
pi
(
*
radius
radius
area
(
define
radius
100
radius
area
(
define
0
1
(
define
error
(
/
1
0
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
(
square
21
(
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
quote
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
define
(
outer
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
(
inner
x
10
(
outer
1
2
(
define
(
outer-func
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
inner
(
(
outer-func
1
2
1
10
(
define
square
(
lambda
(
x
(
*
x
x
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
double
(
lambda
(
x
(
*
2
x
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
and
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
False
5
(
and
4
5
(
+
3
3
(
and
True
False
42
(
/
1
0
(
and
3
2
False
(
and
3
2
1
(
and
3
False
5
(
and
0
1
2
3
(
define
(
true-fn
True
(
and
(
true-fn
(
define
x
False
(
and
x
True
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
False
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
(
no-mutation
(
and
True
True
True
True
no-mutation
(
no-mutation
no-mutation
(
or
(
or
(
+
1
1
(
or
False
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
False
5
(
and
4
5
(
+
3
3
(
and
True
False
42
(
/
1
0
(
and
3
2
False
(
and
3
2
1
(
and
3
False
5
(
and
0
1
2
3
(
define
(
true-fn
True
(
and
(
true-fn
(
define
x
False
(
and
x
True
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
False
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
(
no-mutation
(
and
True
True
True
True
no-mutation
(
no-mutation
no-mutation
(
or
(
or
(
+
1
1
(
or
False
(
define
(
t
True
(
or
(
t
3
(
or
5
2
1
(
or
False
(
-
1
1
1
(
or
4
True
(
/
1
0
(
or
0
1
2
(
or
'
a
False
(
or
(
<
2
3
(
>
2
3
2
'
a
(
or
(
<
2
3
2
(
define
(
false-fn
False
(
or
(
false-fn
'
yay
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
True
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
(
no-mutation
(
or
False
False
False
False
no-mutation
(
no-mutation
no-mutation
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
=
4
3
(
'
hi
(
eval
(
cond
(
False
1
(
False
2
(
cond
(
0
'
yea
(
else
'
nay
(
define
x
0
(
define
y
0
(
define
z
0
(
cond
(
True
(
define
x
(
+
x
1
(
define
y
(
+
y
1
(
define
z
(
+
z
1
(
else
(
define
x
(
-
x
5
(
define
y
(
-
y
5
(
define
z
(
-
z
5
(
list
x
y
z
(
define
(
print-and-false
val
(
print
val
False
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-false
'
cond3
(
(
print-and-false
'
cond4
(
define
(
print-and-true
val
(
print
val
True
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-true
'
cond3
(
(
print-and-false
'
cond4
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
=
4
3
(
'
hi
(
eval
(
cond
(
False
1
(
False
2
(
cond
(
0
'
yea
(
else
'
nay
(
define
x
0
(
define
y
0
(
define
z
0
(
cond
(
True
(
define
x
(
+
x
1
(
define
y
(
+
y
1
(
define
z
(
+
z
1
(
else
(
define
x
(
-
x
5
(
define
y
(
-
y
5
(
define
z
(
-
z
5
(
list
x
y
z
(
define
(
print-and-false
val
(
print
val
False
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-false
'
cond3
(
(
print-and-false
'
cond4
(
define
(
print-and-true
val
(
print
val
True
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-true
'
cond3
(
(
print-and-false
'
cond4
(
define
x
1
(
let
(
(
x
5
(
+
x
3
(
define
x
1
(
let
(
(
x
5
(
+
x
3
nil
1
True
3
-123
1.25
True
(
a
)
)
(
+
23
4
(
+
23
4
(
+
23
4
2
3
2
(
3
4
(
+
1
2
(
+
(
-
2
3
1
(
(
(
a
(
+
1
(
-
2
3
8
(
a
b
(
a
b
c
(
a
b
c
(
a
b
c
(
a
(
b
(
c
(
(
a
(
(
b
(
c
(
1
2
(
1
2
3
(
1
2
(
1
2
(
1
2
(
quote
(
3
4
(
2
3
(
2
3
(
2
(
3
4
5
(
1
2
(
1
2
1
1
1
(
1
2
3
(
1
(
quote
(
2
(
quote
(
3
4
(
1
(
quote
(
2
(
3
4
(
1
(
quote
(
2
(
3
4
+
display
hello
(
+
2
2
(
+
(
+
2
2
(
+
1
3
(
*
1
4
(
yolo
(
+
2
3
(
*
(
+
3
2
(
+
1
7
(
1
2
(
1
(
print
0
(
+
(
odd?
13
(
car
(
list
1
2
3
4
(
car
car
(
odd?
1
2
3
(
+
(
+
1
(
*
2
3
(
+
5
(
+
6
(
+
7
(
*
(
-
(
car
(
cdr
(
cdr
(
list
1
2
3
4
(
car
cdr
(
list
1
(
*
(
car
(
cdr
(
cdr
(
list
1
2
3
4
(
car
(
cdr
(
list
1
2
3
4
(
*
(
car
(
cdr
(
cdr
(
list
1
2
3
4
(
cdr
(
cdr
(
list
1
2
3
4
(
+
(
/
1
0
(
define
size
2
size
(
define
x
(
+
2
3
x
(
define
x
(
+
2
7
x
(
eval
(
define
tau
6.28
(
define
pi
3.14159
(
define
radius
10
(
define
area
(
*
pi
(
*
radius
radius
area
(
define
radius
100
radius
area
(
define
0
1
(
define
error
(
/
1
0
(
quote
hello
'
hello
'
'
hello
(
quote
(
1
2
'
(
1
2
(
quote
(
1
2
'
(
1
(
2
(
car
'
(
1
2
3
(
cdr
'
(
1
2
(
car
(
car
'
(
(
1
(
quote
3
(
eval
(
cons
'
car
'
(
'
(
4
2
(
quote
x
'
x
(
a
b
'
(
a
b
'
(
(
a
(
a
(
b
'
c
(
a
(
b
'
(
c
d
'
)
'
)
'
(
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
'
hello
(
car
'
(
1
2
(
car
'
(
1
2
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
(
begin
(
+
2
3
(
+
5
6
(
begin
(
define
x
3
x
(
begin
30
'
(
+
2
2
(
define
x
0
(
begin
42
(
define
x
(
+
x
1
x
(
begin
30
'
hello
(
begin
(
define
x
3
(
cons
x
'
(
y
z
(
begin
(
define
x
3
(
cons
x
'
(
x
z
(
define
x
0
(
begin
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
lambda
(
x
y
(
+
x
y
(
lambda
(
x
(
+
x
(
+
x
x
(
lambda
(
x
(
lambda
(
2
(
lambda
(
x
y
x
(
define
(
f
x
y
(
+
x
y
f
(
define
(
f
(
+
2
2
f
(
define
(
f
x
(
*
x
x
f
(
define
(
foo
x
1
2
3
4
5
foo
(
define
(
foo
(
/
1
0
foo
(
define
(
f
x
x
(
define
(
f
x
x
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
(
square
21
(
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
quote
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
define
(
outer
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
(
inner
x
10
(
outer
1
2
(
define
(
outer-func
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
inner
(
(
outer-func
1
2
1
10
(
define
square
(
lambda
(
x
(
*
x
x
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
double
(
lambda
(
x
(
*
2
x
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
False
5
(
and
4
5
(
+
3
3
(
and
True
False
42
(
/
1
0
(
and
3
2
False
(
and
3
2
1
(
and
3
False
5
(
and
0
1
2
3
(
define
(
true-fn
True
(
and
(
true-fn
(
define
x
False
(
and
x
True
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
False
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
(
no-mutation
(
and
True
True
True
True
no-mutation
(
no-mutation
no-mutation
(
or
(
or
(
+
1
1
(
or
False
(
define
(
t
True
(
or
(
t
3
(
or
5
2
1
(
or
False
(
-
1
1
1
(
or
4
True
(
/
1
0
(
or
0
1
2
(
or
'
a
False
(
or
(
<
2
3
(
>
2
3
2
'
a
(
or
(
<
2
3
2
(
define
(
false-fn
False
(
or
(
false-fn
'
yay
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
True
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
(
no-mutation
(
or
False
False
False
False
no-mutation
(
no-mutation
no-mutation
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
=
4
3
(
'
hi
(
eval
(
cond
(
False
1
(
False
2
(
cond
(
0
'
yea
(
else
'
nay
(
define
x
0
(
define
y
0
(
define
z
0
(
cond
(
True
(
define
x
(
+
x
1
(
define
y
(
+
y
1
(
define
z
(
+
z
1
(
else
(
define
x
(
-
x
5
(
define
y
(
-
y
5
(
define
z
(
-
z
5
(
list
x
y
z
(
define
(
print-and-false
val
(
print
val
False
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-false
'
cond3
(
(
print-and-false
'
cond4
(
define
(
print-and-true
val
(
print
val
True
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-true
'
cond3
(
(
print-and-false
'
cond4
(
define
x
1
(
let
(
(
x
5
(
+
x
3
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
let
(
(
a
1
(
2
2
a
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
let
(
(
a
1
(
2
2
a
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
let
(
(
a
1
(
2
2
a
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
g
(
lambda
(
x
y
(
f
(
+
x
x
(
g
3
7
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
(
square
21
(
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
quote
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
define
(
outer
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
(
inner
x
10
(
outer
1
2
(
define
(
outer-func
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
inner
(
(
outer-func
1
2
1
10
(
define
square
(
lambda
(
x
(
*
x
x
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
double
(
lambda
(
x
(
*
2
x
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
g
(
lambda
(
x
y
(
f
(
+
x
x
(
g
3
7
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
g
(
lambda
(
x
y
(
f
(
+
x
x
(
g
3
7
(
define
h
(
mu
(
x
(
define
(
high
fn
x
(
fn
(
high
h
2
(
define
(
f
x
(
mu
(
(
lambda
(
y
(
+
x
y
(
define
(
g
x
(
(
(
f
(
+
x
1
(
+
x
2
(
g
3
(
mu
(
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
'
replace-this-line
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
enumerate
'
(
9
8
7
6
5
4
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
a
b
c
d
(
enumerate
'
(
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
enumerate
'
(
9
8
7
6
5
4
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
a
b
c
d
(
enumerate
'
(
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
>=
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
>=
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
>=
total
(
car
denoms
(
list
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
list
(
car
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
list-change
5
'
(
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
7
'
(
5
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
yo
(
else
'
dope
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
yo
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
null?
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
null?
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
null?
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
or
(
null?
expr
(
=
str
(
type
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
or
(
null?
expr
(
=
string
(
type
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
)
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
list?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
list?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
list?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
pair?
1
(
pair?
abs
(
pair?
hi
(
pair?
'
hi
(
pair?
'
(
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
'
yo
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
(
car
expr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
pair?
a
(
define
a
'
a
(
pair?
a
(
pair?
nil
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
let-to-lambda
'
(
+
1
(
let
(
(
a
1
a