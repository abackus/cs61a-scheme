
(2 2)
(2)
(2 2)
(2 2)
(2 2)
(2)
(2 2)
(2)
(2 2)
(2)
(
quote
hello
(
quote
hello
'
hello
(
quote
hello
'
hello
'
'
hello
(
quote
hello
'
hello
(
quote
hello
'
hello
'
'
hello
(
quote
hello
'
(
quote
hello
'
hello
'
'
hello
(
quote
hello
'
hello
'
'
hello
(
quote
hello
(
quote
hello
'
hello
'
'
hello
(
quote
(
1
2
'
(
1
2
(
quote
(
1
2
'
(
1
(
2
(
car
'
(
1
2
3
(
cdr
'
(
1
2
(
car
(
car
'
(
(
1
(
quote
3
(
eval
(
cons
'
car
'
(
'
(
4
2
(
quote
x
'
x
(
a
b
'
(
a
b
'
(
(
a
(
a
(
b
'
c
(
a
(
b
'
(
c
d
'
)
'
)
'
(
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
'
hello
(
car
'
(
1
2
(
car
'
(
1
2
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
(
begin
(
+
2
3
(
+
5
6
(
begin
(
define
x
3
x
(
begin
30
'
(
+
2
2
(
define
x
0
(
begin
42
(
define
x
(
+
x
1
x
(
begin
30
'
hello
(
begin
(
define
x
3
(
cons
x
'
(
y
z
(
begin
(
define
x
3
(
cons
x
'
(
x
z
(
define
x
0
(
begin
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
lambda
(
x
y
(
+
x
y
(
lambda
(
x
(
+
x
(
+
x
x
(
lambda
(
x
(
lambda
(
2
(
lambda
(
x
y
x
(
define
(
f
x
y
(
+
x
y
(
define
(
f
x
y
(
+
x
y
f
(
define
(
f
(
+
2
2
f
(
define
(
f
x
(
*
x
x
f
(
define
(
foo
x
1
2
3
4
5
foo
(
define
(
foo
(
/
1
0
foo
(
define
(
f
x
x
(
define
(
f
x
x
(
define
size
2
size
(
define
x
(
+
2
3
x
(
define
x
(
+
2
7
x
(
eval
(
define
tau
6.28
(
define
pi
3.14159
(
define
radius
10
(
define
area
(
*
pi
(
*
radius
radius
area
(
define
radius
100
radius
area
(
define
0
1
(
define
error
(
/
1
0
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
(
square
21
(
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
quote
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
define
(
outer
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
(
inner
x
10
(
outer
1
2
(
define
(
outer-func
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
inner
(
(
outer-func
1
2
1
10
(
define
square
(
lambda
(
x
(
*
x
x
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
double
(
lambda
(
x
(
*
2
x
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
and
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
False
5
(
and
4
5
(
+
3
3
(
and
True
False
42
(
/
1
0
(
and
3
2
False
(
and
3
2
1
(
and
3
False
5
(
and
0
1
2
3
(
define
(
true-fn
True
(
and
(
true-fn
(
define
x
False
(
and
x
True
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
False
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
(
no-mutation
(
and
True
True
True
True
no-mutation
(
no-mutation
no-mutation
(
or
(
or
(
+
1
1
(
or
False
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
False
5
(
and
4
5
(
+
3
3
(
and
True
False
42
(
/
1
0
(
and
3
2
False
(
and
3
2
1
(
and
3
False
5
(
and
0
1
2
3
(
define
(
true-fn
True
(
and
(
true-fn
(
define
x
False
(
and
x
True
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
False
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
(
no-mutation
(
and
True
True
True
True
no-mutation
(
no-mutation
no-mutation
(
or
(
or
(
+
1
1
(
or
False
(
define
(
t
True
(
or
(
t
3
(
or
5
2
1
(
or
False
(
-
1
1
1
(
or
4
True
(
/
1
0
(
or
0
1
2
(
or
'
a
False
(
or
(
<
2
3
(
>
2
3
2
'
a
(
or
(
<
2
3
2
(
define
(
false-fn
False
(
or
(
false-fn
'
yay
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
True
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
(
no-mutation
(
or
False
False
False
False
no-mutation
(
no-mutation
no-mutation
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
=
4
3
(
'
hi
(
eval
(
cond
(
False
1
(
False
2
(
cond
(
0
'
yea
(
else
'
nay
(
define
x
0
(
define
y
0
(
define
z
0
(
cond
(
True
(
define
x
(
+
x
1
(
define
y
(
+
y
1
(
define
z
(
+
z
1
(
else
(
define
x
(
-
x
5
(
define
y
(
-
y
5
(
define
z
(
-
z
5
(
list
x
y
z
(
define
(
print-and-false
val
(
print
val
False
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-false
'
cond3
(
(
print-and-false
'
cond4
(
define
(
print-and-true
val
(
print
val
True
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-true
'
cond3
(
(
print-and-false
'
cond4
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
=
4
3
(
'
hi
(
eval
(
cond
(
False
1
(
False
2
(
cond
(
0
'
yea
(
else
'
nay
(
define
x
0
(
define
y
0
(
define
z
0
(
cond
(
True
(
define
x
(
+
x
1
(
define
y
(
+
y
1
(
define
z
(
+
z
1
(
else
(
define
x
(
-
x
5
(
define
y
(
-
y
5
(
define
z
(
-
z
5
(
list
x
y
z
(
define
(
print-and-false
val
(
print
val
False
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-false
'
cond3
(
(
print-and-false
'
cond4
(
define
(
print-and-true
val
(
print
val
True
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-true
'
cond3
(
(
print-and-false
'
cond4
(
define
x
1
(
let
(
(
x
5
(
+
x
3
(
define
x
1
(
let
(
(
x
5
(
+
x
3
nil
1
True
3
-123
1.25
True
(
a
)
)
(
+
23
4
(
+
23
4
(
+
23
4
2
3
2
(
3
4
(
+
1
2
(
+
(
-
2
3
1
(
(
(
a
(
+
1
(
-
2
3
8
(
a
b
(
a
b
c
(
a
b
c
(
a
b
c
(
a
(
b
(
c
(
(
a
(
(
b
(
c
(
1
2
(
1
2
3
(
1
2
(
1
2
(
1
2
(
quote
(
3
4
(
2
3
(
2
3
(
2
(
3
4
5
(
1
2
(
1
2
1
1
1
(
1
2
3
(
1
(
quote
(
2
(
quote
(
3
4
(
1
(
quote
(
2
(
3
4
(
1
(
quote
(
2
(
3
4
+
display
hello
(
+
2
2
(
+
(
+
2
2
(
+
1
3
(
*
1
4
(
yolo
(
+
2
3
(
*
(
+
3
2
(
+
1
7
(
1
2
(
1
(
print
0
(
+
(
odd?
13
(
car
(
list
1
2
3
4
(
car
car
(
odd?
1
2
3
(
+
(
+
1
(
*
2
3
(
+
5
(
+
6
(
+
7
(
*
(
-
(
car
(
cdr
(
cdr
(
list
1
2
3
4
(
car
cdr
(
list
1
(
*
(
car
(
cdr
(
cdr
(
list
1
2
3
4
(
car
(
cdr
(
list
1
2
3
4
(
*
(
car
(
cdr
(
cdr
(
list
1
2
3
4
(
cdr
(
cdr
(
list
1
2
3
4
(
+
(
/
1
0
(
define
size
2
size
(
define
x
(
+
2
3
x
(
define
x
(
+
2
7
x
(
eval
(
define
tau
6.28
(
define
pi
3.14159
(
define
radius
10
(
define
area
(
*
pi
(
*
radius
radius
area
(
define
radius
100
radius
area
(
define
0
1
(
define
error
(
/
1
0
(
quote
hello
'
hello
'
'
hello
(
quote
(
1
2
'
(
1
2
(
quote
(
1
2
'
(
1
(
2
(
car
'
(
1
2
3
(
cdr
'
(
1
2
(
car
(
car
'
(
(
1
(
quote
3
(
eval
(
cons
'
car
'
(
'
(
4
2
(
quote
x
'
x
(
a
b
'
(
a
b
'
(
(
a
(
a
(
b
'
c
(
a
(
b
'
(
c
d
'
)
'
)
'
(
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
'
hello
(
car
'
(
1
2
(
car
'
(
1
2
'
(
'
a
'
'
a
'
(
'
(
'
a
'
b
'
c
(
+
'
(
1
2
3
'
(
'
+
'
(
1
2
'
3
(
begin
(
+
2
3
(
+
5
6
(
begin
(
define
x
3
x
(
begin
30
'
(
+
2
2
(
define
x
0
(
begin
42
(
define
x
(
+
x
1
x
(
begin
30
'
hello
(
begin
(
define
x
3
(
cons
x
'
(
y
z
(
begin
(
define
x
3
(
cons
x
'
(
x
z
(
define
x
0
(
begin
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
lambda
(
x
y
(
+
x
y
(
lambda
(
x
(
+
x
(
+
x
x
(
lambda
(
x
(
lambda
(
2
(
lambda
(
x
y
x
(
define
(
f
x
y
(
+
x
y
f
(
define
(
f
(
+
2
2
f
(
define
(
f
x
(
*
x
x
f
(
define
(
foo
x
1
2
3
4
5
foo
(
define
(
foo
(
/
1
0
foo
(
define
(
f
x
x
(
define
(
f
x
x
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
(
square
21
(
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
quote
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
define
(
outer
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
(
inner
x
10
(
outer
1
2
(
define
(
outer-func
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
inner
(
(
outer-func
1
2
1
10
(
define
square
(
lambda
(
x
(
*
x
x
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
double
(
lambda
(
x
(
*
2
x
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
and
(
and
1
False
(
and
(
+
1
1
1
(
and
False
5
(
and
4
5
(
+
3
3
(
and
True
False
42
(
/
1
0
(
and
3
2
False
(
and
3
2
1
(
and
3
False
5
(
and
0
1
2
3
(
define
(
true-fn
True
(
and
(
true-fn
(
define
x
False
(
and
x
True
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
x
0
(
and
(
define
x
(
+
x
1
(
define
x
(
+
x
10
False
(
define
x
(
+
x
100
(
define
x
(
+
x
1000
x
(
define
(
no-mutation
(
and
True
True
True
True
no-mutation
(
no-mutation
no-mutation
(
or
(
or
(
+
1
1
(
or
False
(
define
(
t
True
(
or
(
t
3
(
or
5
2
1
(
or
False
(
-
1
1
1
(
or
4
True
(
/
1
0
(
or
0
1
2
(
or
'
a
False
(
or
(
<
2
3
(
>
2
3
2
'
a
(
or
(
<
2
3
2
(
define
(
false-fn
False
(
or
(
false-fn
'
yay
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
x
0
(
or
(
begin
(
define
x
(
+
x
1
False
(
begin
(
define
x
(
+
x
10
False
True
(
begin
(
define
x
(
+
x
100
False
(
begin
(
define
x
(
+
x
1000
False
x
(
define
(
no-mutation
(
or
False
False
False
False
no-mutation
(
no-mutation
no-mutation
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
else
8
(
cond
(
(
>
2
3
5
(
(
>
2
4
6
(
(
<
2
5
7
(
cond
(
(
>
2
3
(
display
'
oops
(
newline
(
else
9
(
cond
(
(
<
2
1
(
(
>
3
2
(
else
5
(
cond
(
False
1
(
cond
(
(
=
4
3
'
nope
(
(
=
4
4
'
hi
(
else
'
wat
(
cond
(
(
=
4
3
'
wat
(
(
=
4
4
(
else
'
hm
(
cond
(
(
=
4
4
(
+
40
2
(
else
'
wat
0
(
cond
(
12
(
cond
(
(
=
4
3
(
'
hi
(
eval
(
cond
(
False
1
(
False
2
(
cond
(
0
'
yea
(
else
'
nay
(
define
x
0
(
define
y
0
(
define
z
0
(
cond
(
True
(
define
x
(
+
x
1
(
define
y
(
+
y
1
(
define
z
(
+
z
1
(
else
(
define
x
(
-
x
5
(
define
y
(
-
y
5
(
define
z
(
-
z
5
(
list
x
y
z
(
define
(
print-and-false
val
(
print
val
False
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-false
'
cond3
(
(
print-and-false
'
cond4
(
define
(
print-and-true
val
(
print
val
True
(
cond
(
(
print-and-false
'
cond1
(
(
print-and-false
'
cond2
(
(
print-and-true
'
cond3
(
(
print-and-false
'
cond4
(
define
x
1
(
let
(
(
x
5
(
+
x
3
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
let
(
(
a
1
(
2
2
a
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
let
(
(
a
1
(
2
2
a
(
define
x
1
(
let
(
(
x
5
(
+
x
3
x
(
let
(
(
a
1
(
b
a
b
(
let
(
(
x
5
(
let
(
(
x
2
(
y
x
(
+
y
(
*
x
2
(
define
(
square
x
(
*
x
x
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
3
(
define
y
4
(
let
(
(
x
(
+
y
2
(
y
(
+
x
2
(
cons
x
y
(
let
(
(
x
'
hello
x
(
define
z
0
(
let
(
(
a
(
define
z
(
+
z
1
z
(
let
(
(
x
1
(
y
3
(
define
x
(
+
x
1
(
cons
x
y
(
let
(
(
a
1
1
a
(
let
(
(
a
1
(
2
2
a
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
g
(
lambda
(
x
y
(
f
(
+
x
x
(
g
3
7
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
(
square
21
(
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
quote
(
lambda
(
x
(
list
x
(
list
(
quote
quote
x
(
define
(
outer
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
(
inner
x
10
(
outer
1
2
(
define
(
outer-func
x
y
(
define
(
inner
z
x
(
+
x
(
*
y
2
(
*
z
3
inner
(
(
outer-func
1
2
1
10
(
define
square
(
lambda
(
x
(
*
x
x
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
double
(
lambda
(
x
(
*
2
x
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
g
(
lambda
(
x
y
(
f
(
+
x
x
(
g
3
7
(
define
y
1
(
define
f
(
mu
(
x
(
+
x
y
(
define
g
(
lambda
(
x
y
(
f
(
+
x
x
(
g
3
7
(
define
h
(
mu
(
x
(
define
(
high
fn
x
(
fn
(
high
h
2
(
define
(
f
x
(
mu
(
(
lambda
(
y
(
+
x
y
(
define
(
g
x
(
(
(
f
(
+
x
1
(
+
x
2
(
g
3
(
mu
(
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
'
replace-this-line
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
cons
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
enumerate
'
(
9
8
7
6
5
4
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
'
replace-this-line
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
a
b
c
d
(
enumerate
'
(
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
3
4
5
6
(
enumerate
'
(
9
8
7
6
5
4
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
'
replace-this-line
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
'
replace-this-line
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
enumerate
'
(
a
b
c
d
(
enumerate
'
(
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
>=
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
>=
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
>=
total
(
car
denoms
(
list
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
list
(
car
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
cons
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
10
'
(
25
10
5
1
(
list-change
5
'
(
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
(
car
pairs
nil
(
cons
(
cons
(
car
(
car
pairs
(
car
(
cdr
pairs
(
zip
(
cons
(
cdr
(
car
pairs
(
cdr
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
'
replace-this-line
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
list-change
7
'
(
5
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
'
replace-this-line
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
replace-this-line
(
else
'
replace-this-line
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
yo
(
else
'
dope
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
'
yo
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
cons
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
(
cdr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
hi
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
'
(
cons
(
let-to-lambda
form
(
list
(
let-to-lambda
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
list
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
car
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
form
params
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
null?
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
null?
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
null?
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
or
(
null?
expr
(
=
str
(
type
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
or
(
null?
expr
(
=
string
(
type
expr
nil
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
let-to-lambda
(
cdr
(
cdr
(
cdr
expr
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
cons
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
)
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
(
car
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
list?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
list?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
list?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
(
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
pair?
1
(
pair?
abs
(
pair?
hi
(
pair?
'
hi
(
pair?
'
(
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
cond
(
(
null?
expr
nil
(
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
'
yo
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
(
car
expr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
car
expr
(
cdr
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
pair?
a
(
define
a
'
a
(
pair?
a
(
pair?
nil
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
cons
(
let-to-lambda
(
car
expr
(
let-to-lambda
(
cdr
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
car
x
values
body
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
map
(
lambda
(
x
(
let-to-lambda
(
car
x
values
body
(
map
(
lambda
(
x
(
let-to-lambda
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
let-to-lambda
'
(
+
1
(
let
(
(
a
1
a
(
define
(
sum
n
total
(
if
(
zero?
n
total
(
sum
(
-
n
1
(
+
n
total
(
sum
1001
0
(
load
'
questions
(
load
'
questions
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
list-change
10
'
(
25
10
5
1
(
list-change
5
'
(
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
list-change
7
'
(
5
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
>=
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
>=
total
(
car
denoms
(
append
(
list
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
list-change
10
'
(
25
10
5
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
list-change
10
'
(
25
10
5
1
(
list-change
5
'
(
4
3
2
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
list-change
7
'
(
5
4
3
2
1
10
(
+
137
349
(
-
1000
334
(
*
5
99
(
/
10
5
(
+
2.7
10
(
+
21
35
12
7
(
*
25
4
12
(
+
(
*
3
5
(
-
10
6
(
+
(
*
3
(
+
(
*
2
4
(
+
3
5
(
+
(
-
10
7
6
(
+
(
*
3
(
+
(
*
2
4
(
+
3
5
(
+
(
-
10
7
6
(
exit
10
(
+
137
349
(
-
1000
334
(
*
5
99
(
/
10
5
(
+
2.7
10
(
+
21
35
12
7
(
*
25
4
12
(
+
(
*
3
5
(
-
10
6
(
+
(
*
3
(
+
(
*
2
4
(
+
3
5
(
+
(
-
10
7
6
(
+
(
*
3
(
+
(
*
2
4
(
+
3
5
(
+
(
-
10
7
6
(
define
size
2
size
(
*
5
size
(
define
pi
3.14159
(
define
radius
10
(
*
pi
(
*
radius
radius
(
define
circumference
(
*
2
pi
radius
circumference
(
define
(
square
x
(
*
x
x
(
square
21
(
define
square
(
lambda
(
x
(
*
x
x
(
square
21
(
square
(
+
2
5
(
square
(
square
3
(
define
(
sum-of-squares
x
y
(
+
(
square
x
(
square
y
(
sum-of-squares
3
4
(
define
(
f
a
(
sum-of-squares
(
+
a
1
(
*
a
2
(
f
5
(
define
(
abs
x
(
cond
(
(
>
x
0
x
(
(
=
x
0
0
(
(
<
x
0
(
-
x
(
abs
-3
(
abs
0
(
abs
3
(
define
(
a-plus-abs-b
a
b
(
(
if
(
>
b
0
+
-
a
b
(
a-plus-abs-b
3
-2
(
define
(
sqrt-iter
guess
x
(
if
(
good-enough?
guess
x
guess
(
sqrt-iter
(
improve
guess
x
x
(
define
(
improve
guess
x
(
average
guess
(
/
x
guess
(
define
(
average
x
y
(
/
(
+
x
y
2
(
define
(
good-enough?
guess
x
(
<
(
abs
(
-
(
square
guess
x
0.001
(
define
(
sqrt
x
(
sqrt-iter
1.0
x
(
sqrt
9
(
sqrt
(
+
100
37
(
sqrt
(
+
(
sqrt
2
(
sqrt
3
(
square
(
sqrt
1000
(
define
(
sqrt
x
(
define
(
good-enough?
guess
(
<
(
abs
(
-
(
square
guess
x
0.001
(
define
(
improve
guess
(
average
guess
(
/
x
guess
(
define
(
sqrt-iter
guess
(
if
(
good-enough?
guess
guess
(
sqrt-iter
(
improve
guess
(
sqrt-iter
1.0
(
sqrt
9
(
sqrt
(
+
100
37
(
sqrt
(
+
(
sqrt
2
(
sqrt
3
(
square
(
sqrt
1000
(
define
(
cube
x
(
*
x
x
x
(
define
(
sum
term
a
next
b
(
if
(
>
a
b
0
(
+
(
term
a
(
sum
term
(
next
a
next
b
(
define
(
inc
n
(
+
n
1
(
define
(
sum-cubes
a
b
(
sum
cube
a
inc
b
(
sum-cubes
1
10
(
define
(
identity
x
x
(
define
(
sum-integers
a
b
(
sum
identity
a
inc
b
(
sum-integers
1
10
(
(
lambda
(
x
y
z
(
+
x
y
(
square
z
1
2
3
(
define
(
f
x
y
(
let
(
(
a
(
+
1
(
*
x
y
(
b
(
-
1
y
(
+
(
*
x
(
square
a
(
*
y
b
(
*
a
b
(
f
3
4
(
define
x
5
(
+
(
let
(
(
x
3
(
+
x
(
*
x
10
x
(
let
(
(
x
3
(
y
(
+
x
2
(
*
x
y
(
define
(
add-rat
x
y
(
make-rat
(
+
(
*
(
numer
x
(
denom
y
(
*
(
numer
y
(
denom
x
(
*
(
denom
x
(
denom
y
(
define
(
sub-rat
x
y
(
make-rat
(
-
(
*
(
numer
x
(
denom
y
(
*
(
numer
y
(
denom
x
(
*
(
denom
x
(
denom
y
(
define
(
mul-rat
x
y
(
make-rat
(
*
(
numer
x
(
numer
y
(
*
(
denom
x
(
denom
y
(
define
(
div-rat
x
y
(
make-rat
(
*
(
numer
x
(
denom
y
(
*
(
denom
x
(
numer
y
(
define
(
equal-rat?
x
y
(
=
(
*
(
numer
x
(
denom
y
(
*
(
numer
y
(
denom
x
(
define
x
(
cons
1
2
(
car
x
(
cdr
x
(
define
x
(
cons
1
2
(
define
y
(
cons
3
4
(
define
z
(
cons
x
y
(
car
(
car
z
(
car
(
cdr
z
z
(
define
(
make-rat
n
d
(
cons
n
d
(
define
(
numer
x
(
car
x
(
define
(
denom
x
(
cdr
x
(
define
(
print-rat
x
(
display
(
numer
x
(
display
'
/
(
display
(
denom
x
(
newline
(
define
one-half
(
make-rat
1
2
(
print-rat
one-half
(
define
one-third
(
make-rat
1
3
(
print-rat
(
add-rat
one-half
one-third
(
print-rat
(
mul-rat
one-half
one-third
(
print-rat
(
add-rat
one-third
one-third
(
define
(
gcd
a
b
(
if
(
=
b
0
a
(
gcd
b
(
remainder
a
b
(
define
(
make-rat
n
d
(
let
(
(
g
(
gcd
n
d
(
cons
(
/
n
g
(
/
d
g
(
print-rat
(
add-rat
one-third
one-third
(
define
one-through-four
(
list
1
2
3
4
one-through-four
(
car
one-through-four
(
cdr
one-through-four
(
car
(
cdr
one-through-four
(
cons
10
one-through-four
(
cons
5
one-through-four
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
map
abs
(
list
-10
2.5
-11.6
17
(
map
(
lambda
(
x
(
*
x
x
(
list
1
2
3
4
(
define
(
scale-list
items
factor
(
map
(
lambda
(
x
(
*
x
factor
items
(
scale-list
(
list
1
2
3
4
5
10
(
define
(
count-leaves
x
(
cond
(
(
null?
x
0
(
(
not
(
pair?
x
1
(
else
(
+
(
count-leaves
(
car
x
(
count-leaves
(
cdr
x
(
define
x
(
cons
(
list
1
2
(
list
3
4
(
count-leaves
x
(
count-leaves
(
list
x
x
(
define
(
odd?
x
(
=
1
(
remainder
x
2
(
define
(
filter
predicate
sequence
(
cond
(
(
null?
sequence
nil
(
(
predicate
(
car
sequence
(
cons
(
car
sequence
(
filter
predicate
(
cdr
sequence
(
else
(
filter
predicate
(
cdr
sequence
(
filter
odd?
(
list
1
2
3
4
5
(
define
(
accumulate
op
initial
sequence
(
if
(
null?
sequence
initial
(
op
(
car
sequence
(
accumulate
op
initial
(
cdr
sequence
(
accumulate
+
0
(
list
1
2
3
4
5
(
accumulate
*
1
(
list
1
2
3
4
5
(
accumulate
cons
nil
(
list
1
2
3
4
5
(
define
(
enumerate-interval
low
high
(
if
(
>
low
high
nil
(
cons
low
(
enumerate-interval
(
+
low
1
high
(
enumerate-interval
2
7
(
define
(
enumerate-tree
tree
(
cond
(
(
null?
tree
nil
(
(
not
(
pair?
tree
(
list
tree
(
else
(
append
(
enumerate-tree
(
car
tree
(
enumerate-tree
(
cdr
tree
(
enumerate-tree
(
list
1
(
list
2
(
list
3
4
5
(
define
a
1
(
define
b
2
(
list
a
b
(
list
'
a
'
b
(
list
'
a
b
(
car
'
(
a
b
c
(
cdr
'
(
a
b
c
(
define
(
memq
item
x
(
cond
(
(
null?
x
False
(
(
equal?
item
(
car
x
x
(
else
(
memq
item
(
cdr
x
(
memq
'
apple
'
(
pear
banana
prune
(
memq
'
apple
'
(
x
(
apple
sauce
y
apple
pear
(
define
(
my-equal?
x
y
(
cond
(
(
pair?
x
(
and
(
pair?
y
(
my-equal?
(
car
x
(
car
y
(
my-equal?
(
cdr
x
(
cdr
y
(
(
null?
x
(
null?
y
(
else
(
equal?
x
y
(
my-equal?
'
(
1
2
(
three
'
(
1
2
(
three
(
my-equal?
'
(
1
2
(
three
'
(
1
2
three
(
my-equal?
'
(
1
2
three
'
(
1
2
(
three
(
define
double
(
lambda
(
x
(
*
2
x
(
double
5
(
define
compose
(
lambda
(
f
g
(
lambda
(
x
(
f
(
g
x
(
(
compose
list
double
5
(
define
apply-twice
(
lambda
(
f
(
compose
f
f
(
(
apply-twice
double
5
(
(
apply-twice
(
apply-twice
double
5
(
define
fact
(
lambda
(
n
(
if
(
<=
n
1
1
(
*
n
(
fact
(
-
n
1
(
fact
3
(
fact
50
(
define
(
combine
f
(
lambda
(
x
y
(
if
(
null?
x
nil
(
f
(
list
(
car
x
(
car
y
(
(
combine
f
(
cdr
x
(
cdr
y
(
define
zip
(
combine
cons
(
zip
(
list
1
2
3
4
(
list
5
6
7
8
(
define
riff-shuffle
(
lambda
(
deck
(
begin
(
define
take
(
lambda
(
n
seq
(
if
(
<=
n
0
(
quote
(
(
cons
(
car
seq
(
take
(
-
n
1
(
cdr
seq
(
define
drop
(
lambda
(
n
seq
(
if
(
<=
n
0
seq
(
drop
(
-
n
1
(
cdr
seq
(
define
mid
(
lambda
(
seq
(
/
(
length
seq
2
(
(
combine
append
(
take
(
mid
deck
deck
(
drop
(
mid
deck
deck
(
riff-shuffle
(
list
1
2
3
4
5
6
7
8
(
(
apply-twice
riff-shuffle
(
list
1
2
3
4
5
6
7
8
(
riff-shuffle
(
riff-shuffle
(
riff-shuffle
(
list
1
2
3
4
5
6
7
8
(
apply
square
'
(
2
(
apply
+
'
(
1
2
3
4
(
apply
(
if
False
+
append
'
(
(
1
2
(
3
4
(
if
0
1
2
(
if
'
(
1
2
(
or
False
True
(
or
(
and
(
or
1
2
3
(
and
1
2
3
(
and
False
(
/
1
0
(
and
True
(
/
1
0
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
(
list
nil
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
(
list
nil
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
(
list
nil
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
if
(
null?
pairs
(
list
nil
nil
(
list
(
cons
(
car
(
car
pairs
(
car
(
zip
(
cdr
pairs
(
cons
(
car
(
cdr
(
car
(
pairs
(
car
(
cdr
(
zip
(
cdr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
let-to-lambda
'
(
+
1
(
let
(
(
a
1
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
)
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
list
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
cons
(
let-to-lambda
(
cadr
(
zip
values
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
cons
(
let-to-lambda
(
cadr
(
zip
values
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
map
(
lambda
(
x
(
car
x
values
(
let-to-lambda
body
(
let-to-lambda
(
map
(
lambda
(
x
(
car
(
cdr
x
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
(
lambda
(
pair
(
car
pair
pairs
(
map
(
lambda
(
pair
(
cadr
pair
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
let-to-lambda
'
(
+
1
(
let
(
(
a
1
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
car
pairs
(
map
cadr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
1
(
let-to-lambda
'
a
(
let-to-lambda
'
(
+
1
2
(
let-to-lambda
'
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
car
pairs
(
map
cadr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
quoted
expressions
remain
the
same
(
let-to-lambda
'
(
quote
(
let
(
(
a
1
(
b
2
(
+
a
b
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
car
pairs
(
map
cadr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
'
(
lambda
parameters
not
affected
but
body
affected
(
let-to-lambda
'
(
lambda
(
let
a
b
(
+
let
a
b
(
let-to-lambda
'
(
lambda
(
x
a
(
let
(
(
a
x
a
(
load
'
questions
(
define
(
caar
x
(
car
(
car
x
(
define
(
cadr
x
(
car
(
cdr
x
(
define
(
cdar
x
(
cdr
(
car
x
(
define
(
cddr
x
(
cdr
(
cdr
x
(
define
(
map
proc
items
(
if
(
null?
items
nil
(
cons
(
proc
(
car
items
(
map
proc
(
cdr
items
(
define
(
cons-all
first
rests
(
map
(
lambda
(
x
(
cons
first
x
rests
(
define
(
zip
pairs
(
list
(
map
car
pairs
(
map
cadr
pairs
(
define
(
enumerate
s
(
define
(
enum-help
s
k
(
if
(
null?
s
nil
(
cons
(
list
k
(
car
s
(
enum-help
(
cdr
s
(
+
k
1
(
enum-help
s
0
(
define
(
list-change
total
denoms
(
cond
(
(
=
total
0
nil
(
(
null?
denoms
nil
(
(
=
total
(
car
denoms
(
cons
(
list
(
car
denoms
(
list-change
total
(
cdr
denoms
(
(
>
total
(
car
denoms
(
append
(
cons-all
(
car
denoms
(
list-change
(
-
total
(
car
denoms
denoms
(
list-change
total
(
cdr
denoms
(
else
(
list-change
total
(
cdr
denoms
(
define
(
check-special
form
(
lambda
(
expr
(
equal?
form
(
car
expr
(
define
lambda?
(
check-special
'
lambda
(
define
define?
(
check-special
'
define
(
define
quoted?
(
check-special
'
quote
(
define
let?
(
check-special
'
let
(
define
(
let-to-lambda
expr
(
cond
(
(
atom?
expr
expr
(
(
quoted?
expr
expr
(
(
or
(
lambda?
expr
(
define?
expr
(
let
(
(
form
(
car
expr
(
params
(
cadr
expr
(
body
(
cddr
expr
(
cons
form
(
cons
params
(
map
let-to-lambda
body
(
(
let?
expr
(
let
(
(
values
(
cadr
expr
(
body
(
cddr
expr
(
cons
(
cons
'
lambda
(
cons
(
let-to-lambda
(
car
(
zip
values
(
let-to-lambda
body
(
let-to-lambda
(
cadr
(
zip
values
(
else
(
if
(
pair?
expr
(
map
let-to-lambda
expr
expr
(
let-to-lambda
'
(
let
(
(
a
(
let
(
(
a
2
a
(
b
2
(
+
a
b
(
let-to-lambda
'
(
let
(
(
a
1
(
let
(
(
b
a
b
(
let-to-lambda
'
(
+
1
(
let
(
(
a
1
a